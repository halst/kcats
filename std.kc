max:             # a b
    [2] [2] >    # a>b
    [3] [3] <    # a<b
    [3] *        # a>b * a
    swp [4] *    # a<b * b
    +            # result
    swp x swp x  # clean up
    ret

max{             # a b
    [2] [2] >    # a>b
    [3] [3] <    # a<b
    [3] *        # a>b * a
    swp [4] *    # a<b * b
    +            # result
    swp x swp x  # clean up
}

k> 10 20 max -1 *

math.sqrt

q: built-in
c: built-in
swp: built-in
x: built-in
+: built-in
^: built-in
*: built-in
/: built-in
>: built-in
nand: built-in

# num -> bool
not: 0? -> 1 . 0

# num num -> bool
and: * bool .

# num -> bool
bool: not not .

e1 : c1 ,
e2 : c2 ,
   : c3 .

sign: 
    if [1] 0 > then x +1 return
    if [1] 0 < then x -1 return
                       0 return    


sign: 
    if [1] 0 > then 
        x +1 
    else if [1] 0 < then 
        x -1 
    else 0 end if 
    return 
     
sign: 
    if [1] 0 > : 
        x +1 
    elif [1] 0 < : 
        x -1 
    else 0 ; 
    return 

sign: 
    [1] 0 > : x +1 .
    [1] 0 < : x -1 .
              0 .    
sign: 
    [1] 0 > : x +1 ,
    [1] 0 < : x -1 ,
              0 ; .

fact: [1] 0 == then fact(0) [1] 1 == then return fact(n) return
fact(0): x 1 return
fact(n): [1] 1 - fact * return

fact 0 = 1
fact n = n * fact (n - 1)

fact: 
    [1] 0 == then: x 1 
             else: [1] 1 - fact * .
fact: 
    [1] 0 == then: x 1 . 
                   [1] 1 - fact * .
fact: 
    [1] 0 == : x 1 . 
  x [1] 1 == :           [1] 1 - fact * .
             

<: swp >
abs: 2 ^ 0.5 ^
==: [2] [2] > [3] [3] < or ! swp x swp x
e: 2.71822 
pi: 3.14159
!=: == !
dup: [1]
dup2: [2] [1]
-: -1 * +
>=: < !
<=: > !
not: dup nand
!: not
and: nand not
or: ! swp ! and !
nor: not or
xor: dup nand swp [2] nand swp [3] nand nand swp x
xnor: xor not
max: [2] [2] > [3] [3] < [3] * swp [4] * + swp x swp x
min: [2] [2] < [3] [3] > [3] * swp [4] * + swp x swp x 
